<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Monitoring - Real-time</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
        rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            height: 100vh;
        }

        #map {
            width: 100%;
            height: 100vh;
            position: relative;
            z-index: 1;
        }

        /* Header Stats Panel */
        .stats-panel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 10px 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            display: flex;
            gap: 20px;
            align-items: center;
            transition: all 0.3s ease;
        }

        .stats-panel.collapsed {
            padding: 8px 12px;
            gap: 0;
        }

        .stats-panel.collapsed .stat-item {
            display: none;
        }

        .stats-toggle {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .stats-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 800;
            line-height: 1;
        }

        .stat-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #64748b;
        }

        .stat-online .stat-value {
            color: #10b981;
        }

        .stat-offline .stat-value {
            color: #ef4444;
        }

        .stat-warning .stat-value {
            color: #f59e0b;
        }

        .stat-total .stat-value {
            color: #3b82f6;
        }

        /* Control Panel */
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            width: 220px;
            transition: all 0.3s ease;
        }

        .control-panel.collapsed {
            width: 50px;
            height: 50px;
            overflow: hidden;
        }

        .control-panel.collapsed .control-content {
            display: none;
        }

        .control-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .control-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .control-content {
            padding: 15px;
            padding-top: 45px;
        }

        .control-panel h3 {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 12px;
            color: #1e293b;
        }

        .control-btn {
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 8px;
            border: none;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .control-btn i {
            font-size: 12px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .filter-group {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #e2e8f0;
        }

        .filter-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            margin-bottom: 6px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-item:hover {
            background: #f1f5f9;
        }

        .filter-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .filter-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 500;
        }

        .filter-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
        }

        /* Status Indicator */
        .status-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .status-text {
            font-size: 14px;
            font-weight: 600;
            color: #1e293b;
        }

        /* Custom Leaflet Popup */
        .leaflet-popup-content-wrapper {
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .device-popup {
            min-width: 250px;
            padding: 10px;
        }

        .device-popup h4 {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 10px;
            color: #1e293b;
        }

        .device-popup-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 13px;
        }

        .device-popup-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .device-popup-row:last-child {
            border-bottom: none;
        }

        .device-popup-label {
            font-weight: 600;
            color: #64748b;
        }

        .device-popup-value {
            font-weight: 500;
            color: #1e293b;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-online {
            background: #d1fae5;
            color: #065f46;
        }

        .status-offline {
            background: #fee2e2;
            color: #991b1b;
        }

        .status-warning {
            background: #fef3c7;
            color: #92400e;
        }

        /* Distance Info */
        .distance-info {
            margin-top: 10px;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            color: white;
            text-align: center;
        }

        .distance-value {
            font-size: 20px;
            font-weight: 800;
            margin-bottom: 5px;
        }

        .distance-label {
            font-size: 11px;
            opacity: 0.9;
        }

        /* Animated Links */
        .network-link {
            stroke-dasharray: 10, 5;
            animation: dash 20s linear infinite;
            stroke-linecap: round;
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.4));
            transition: stroke 0.5s ease, stroke-width 0.5s ease;
        }

        .link-up {
            stroke: #10b981;
            animation: dash 15s linear infinite;
        }

        .link-down {
            stroke: #ef4444;
            stroke-dasharray: 5, 2;
            animation: blinkRed 1s ease-in-out infinite;
        }

        /* OLT-ODC Links (Purple Blinking & Flowing) */
        .link-olt-odc {
            stroke: #8B5CF6;
            stroke-width: 4 !important;
            animation: dash 10s linear infinite, blinkPurple 2s ease-in-out infinite;
            filter: drop-shadow(0 0 5px #8B5CF6);
        }

        /* ODC-ODP Links (Light Blue Flowing) */
        .link-odc-odp {
            stroke: #3B82F6;
            stroke-width: 3 !important;
            animation: dash 15s linear infinite;
            filter: drop-shadow(0 0 3px #3B82F6);
        }

        /* Customer Links */
        .link-customer-online {
            stroke: #10B981;
            stroke-width: 2 !important;
            animation: dash 25s linear infinite;
            filter: drop-shadow(0 0 2px #10B981);
        }

        .link-customer-offline {
            stroke: #EF4444;
            stroke-width: 2 !important;
            stroke-dasharray: 4, 4;
            opacity: 0.6;
        }

        /* Distance Label on Link */
        .link-distance-label {
            font-size: 10px;
            font-weight: bold;
            fill: white;
            text-shadow: 0px 0px 4px #000;
            cursor: pointer;
        }

        .link-distance-bg {
            fill: rgba(0, 0, 0, 0.6);
            rx: 4;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -1000;
            }
        }

        @keyframes blinkGreen {

            0%,
            100% {
                opacity: 1;
                stroke-width: 3;
            }

            50% {
                opacity: 0.6;
                stroke-width: 4;
            }
        }

        @keyframes blinkRed {

            0%,
            100% {
                opacity: 1;
                stroke-width: 3;
            }

            50% {
                opacity: 0.3;
                stroke-width: 5;
            }
        }

        @keyframes blinkPurple {

            0%,
            100% {
                opacity: 1;
                stroke-width: 4;
            }

            50% {
                opacity: 0.5;
                stroke-width: 6;
            }
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 20px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            color: white;
            font-size: 18px;
            font-weight: 600;
        }

        /* Hide Leaflet Routing Machine instructions panel */
        .leaflet-routing-container {
            display: none !important;
        }

        /* Route Info Panel */
        .route-info-panel {
            position: absolute;
            bottom: 80px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            width: 280px;
            transition: all 0.3s ease;
            border-left: 5px solid #667eea;
        }

        .route-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .route-info-header h4 {
            font-size: 14px;
            font-weight: 700;
            color: #1e293b;
            margin: 0;
        }

        .route-info-header button {
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            font-size: 16px;
            transition: color 0.2s;
        }

        .route-info-header button:hover {
            color: #ef4444;
        }

        .route-info-body {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .route-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .route-stat .label {
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
        }

        .route-stat .value {
            font-size: 15px;
            font-weight: 700;
            color: #1e293b;
        }

        .route-devices {
            margin-top: 5px;
            padding: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .device-point {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            font-weight: 500;
            color: #475569;
        }

        .route-line {
            width: 2px;
            height: 15px;
            background: #e2e8f0;
            margin-left: 4px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .stats-panel {
                flex-direction: column;
                gap: 15px;
                padding: 15px 20px;
            }

            .stats-panel h1 {
                font-size: 18px;
                margin-right: 0;
            }

            .control-panel {
                width: 250px;
            }
        }
    </style>
</head>

<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Network Map...</div>
    </div>

    <!-- Stats Panel -->
    <div class="stats-panel collapsed" id="statsPanel">
        <button class="stats-toggle" onclick="toggleStatsPanel()">
            <i class="fas fa-chart-bar" id="statsToggleIcon"></i>
        </button>
        <div class="stat-item stat-online">
            <div class="stat-value" id="statOnline">0</div>
            <div class="stat-label">Online</div>
        </div>
        <div class="stat-item stat-offline">
            <div class="stat-value" id="statOffline">0</div>
            <div class="stat-label">Offline</div>
        </div>
        <div class="stat-item stat-warning">
            <div class="stat-value" id="statWarning">0</div>
            <div class="stat-label">Warning</div>
        </div>
        <div class="stat-item stat-total">
            <div class="stat-value" id="statTotal">0</div>
            <div class="stat-label">Total</div>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel collapsed" id="controlPanel">
        <button class="control-toggle" onclick="toggleControlPanel()">
            <i class="fas fa-bars" id="toggleIcon"></i>
        </button>

        <div class="control-content">
            <h3><i class="fas fa-sliders-h"></i> Controls</h3>

            <button class="control-btn btn-primary" onclick="refreshData()">
                <i class="fas fa-sync-alt"></i>
                Refresh
            </button>

            <button class="control-btn btn-success" onclick="syncAll()">
                <i class="fas fa-download"></i>
                Sync All
            </button>

            <div class="filter-group">
                <h3><i class="fas fa-filter"></i> Filters</h3>

                <div class="filter-item" onclick="toggleFilter('customer')">
                    <div class="filter-label">
                        <div class="filter-icon" style="background: #3b82f6; color: white;">
                            <i class="fas fa-user"></i>
                        </div>
                        <span>Customers</span>
                    </div>
                    <input type="checkbox" id="filter-customer" checked>
                </div>

                <div class="filter-item" onclick="toggleFilter('ont')">
                    <div class="filter-label">
                        <div class="filter-icon" style="background: #10b981; color: white;">
                            <i class="fas fa-router"></i>
                        </div>
                        <span>ONTs</span>
                    </div>
                    <input type="checkbox" id="filter-ont" checked>
                </div>

                <div class="filter-item" onclick="toggleFilter('olt')">
                    <div class="filter-label">
                        <div class="filter-icon" style="background: #8b5cf6; color: white;">
                            <i class="fas fa-server"></i>
                        </div>
                        <span>OLTs</span>
                    </div>
                    <input type="checkbox" id="filter-olt" checked>
                </div>

                <div class="filter-item" onclick="toggleFilter('odc')">
                    <div class="filter-label">
                        <div class="filter-icon" style="background: #f59e0b; color: white;">
                            <i class="fas fa-box"></i>
                        </div>
                        <span>ODCs</span>
                    </div>
                    <input type="checkbox" id="filter-odc" checked>
                </div>

                <div class="filter-item" onclick="toggleFilter('odp')">
                    <div class="filter-label">
                        <div class="filter-icon" style="background: #ec4899; color: white;">
                            <i class="fas fa-cube"></i>
                        </div>
                        <span>ODPs</span>
                    </div>
                    <input type="checkbox" id="filter-odp" checked>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Indicator -->
    <div class="status-indicator">
        <div class="status-dot" id="statusDot"></div>
        <div class="status-text" id="statusText">Connecting...</div>
    </div>

    <!-- Route Info Panel -->
    <div id="routeInfoPanel" style="display: none;" class="route-info-panel">
        <div class="route-info-header">
            <h4><i class="fas fa-route"></i> Route Details</h4>
            <button onclick="closeRouteInfo()"><i class="fas fa-times"></i></button>
        </div>
        <div class="route-info-body">
            <div class="route-stat">
                <span class="label">Distance</span>
                <span class="value" id="routeDistance">0 km</span>
            </div>
            <div class="route-stat">
                <span class="label">Time (Walk)</span>
                <span class="value" id="routeTime">0 min</span>
            </div>
            <div class="route-devices">
                <div class="device-point">
                    <i class="fas fa-circle-dot" style="color: #667eea"></i>
                    <span id="routeFrom">Source</span>
                </div>
                <div class="route-line"></div>
                <div class="device-point">
                    <i class="fas fa-location-dot" style="color: #764ba2"></i>
                    <span id="routeTo">Destination</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Map Container -->
    <div id="map"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Leaflet Routing Machine (for walking distance) -->
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <script>
        // Global variables
        let map;
        let markers = {};
        let linkLayers = L.layerGroup(); // Use layer group for links
        let currentLinks = []; // Store active links
        let activeFilters = {
            customer: true,
            ont: true,
            olt: true,
            odc: true,
            odp: true
        };
        let selectedDevice = null;
        let routingControl = null;
        let deviceMap = {};
        let linksMap = {}; // Track active link polyline objects

        // Initialize map
        function initMap() {
            // Start with default center (will be updated after loading data)
            map = L.map('map').setView([-6.200000, 106.816666], 13);

            // Add tile layer with dark theme
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 20
            }).addTo(map);

            // Add link layers to map
            linkLayers.addTo(map);

            // Load data
            loadNetworkData();

            // Auto refresh every 10 seconds for "live" feel
            setInterval(refreshData, 10000);
        }

        // Calculate center point from customer locations
        function calculateCustomerCenter(devices) {
            const customers = devices.filter(d =>
                d.device_type === 'customer' &&
                d.latitude !== null && d.latitude !== undefined &&
                d.longitude !== null && d.longitude !== undefined &&
                !isNaN(parseFloat(d.latitude)) && !isNaN(parseFloat(d.longitude))
            );

            if (customers.length === 0) {
                return { lat: -6.200000, lng: 106.816666, zoom: 13 }; // Default Jakarta
            }

            // Calculate average position (center of mass)
            let totalLat = 0;
            let totalLng = 0;

            customers.forEach(customer => {
                totalLat += parseFloat(customer.latitude);
                totalLng += parseFloat(customer.longitude);
            });

            if (isNaN(totalLat) || isNaN(totalLng) || customers.length === 0) {
                return { lat: -6.200000, lng: 106.816666, zoom: 13 };
            }

            const centerLat = totalLat / customers.length;
            const centerLng = totalLng / customers.length;

            if (isNaN(centerLat) || isNaN(centerLng)) {
                return { lat: -6.200000, lng: 106.816666, zoom: 13 };
            }

            // Calculate appropriate zoom level based on spread
            let maxDistance = 0;
            customers.forEach(customer => {
                const distance = Math.sqrt(
                    Math.pow(parseFloat(customer.latitude) - centerLat, 2) +
                    Math.pow(parseFloat(customer.longitude) - centerLng, 2)
                );
                maxDistance = Math.max(maxDistance, distance);
            });

            // Determine zoom level (rough approximation)
            let zoom = 13;
            if (maxDistance > 0.5) zoom = 10;
            else if (maxDistance > 0.2) zoom = 11;
            else if (maxDistance > 0.1) zoom = 12;
            else if (maxDistance > 0.05) zoom = 13;
            else zoom = 14;

            console.log(`üìç Auto-centered to customer cluster: ${customers.length} customers at [${centerLat.toFixed(4)}, ${centerLng.toFixed(4)}], zoom: ${zoom}`);

            return { lat: centerLat, lng: centerLng, zoom };
        }

        // Toggle stats panel
        function toggleStatsPanel() {
            const panel = document.getElementById('statsPanel');
            const icon = document.getElementById('statsToggleIcon');

            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                icon.className = 'fas fa-times';
            } else {
                panel.classList.add('collapsed');
                icon.className = 'fas fa-chart-bar';
            }
        }

        // Load network topology data
        async function loadNetworkData() {
            try {
                const response = await fetch('/monitoring/api/network-topology');
                const result = await response.json();

                if (result.success) {
                    // Update connection status in indicator
                    const dot = document.getElementById('statusDot');
                    const text = document.getElementById('statusText');
                    if (dot) dot.style.background = '#10b981';
                    if (text) text.textContent = 'Live Monitoring Active';

                    // Auto-center map to customer cluster
                    const center = calculateCustomerCenter(result.data.devices);
                    // Only set view on first load
                    if (!map.hasSetView) {
                        map.setView([center.lat, center.lng], center.zoom);
                        map.hasSetView = true;
                    }

                    renderDevices(result.data.devices);

                    // Update global links
                    currentLinks = result.data.links;
                    renderLinks(currentLinks);

                    updateStats(result.data.statistics);

                    // Successfully loaded - hide loading overlay
                    document.getElementById('loadingOverlay').style.display = 'none';
                } else {
                    throw new Error(result.error || 'Unknown error');
                }

            } catch (error) {
                console.error('Error loading network data:', error);
                const dot = document.getElementById('statusDot');
                const text = document.getElementById('statusText');
                if (dot) dot.style.background = '#ef4444';
                if (text) text.textContent = 'Connection Error - Retrying...';

                // Show error message on first load if it fails
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay.style.display !== 'none') {
                    loadingOverlay.innerHTML = `
                        <div class="loading-text" style="color: #ef4444; text-align: center;">
                            <i class="fas fa-exclamation-triangle"></i> Error loading data<br>
                            <span style="font-size: 12px; font-weight: normal; opacity: 0.8;">${error.message}</span>
                        </div>
                        <button onclick="refreshData()" class="control-btn btn-primary" style="width: auto; margin-top: 15px;">Retry Now</button>
                    `;
                }
            }
        }

        // Render devices on map
        function renderDevices(devices) {
            const currentDeviceIds = new Set(devices.map(d => d.id.toString()));

            // Remove markers for deleted devices
            Object.keys(markers).forEach(id => {
                if (!currentDeviceIds.has(id)) {
                    markers[id].remove();
                    delete markers[id];
                }
            });

            deviceMap = {};

            devices.forEach(device => {
                deviceMap[device.id] = device;

                const lat = parseFloat(device.latitude);
                const lng = parseFloat(device.longitude);
                if (isNaN(lat) || isNaN(lng)) return;

                if (!activeFilters[device.device_type]) {
                    if (markers[device.id]) {
                        markers[device.id].remove();
                        delete markers[device.id];
                    }
                    return;
                }

                const icon = getDeviceIcon(device);
                const popupContent = createDevicePopup(device);

                if (markers[device.id]) {
                    // Update existing marker
                    const marker = markers[device.id];
                    if (marker.getLatLng().lat !== lat || marker.getLatLng().lng !== lng) {
                        marker.setLatLng([lat, lng]);
                    }
                    marker.setIcon(icon);
                    marker.setPopupContent(popupContent);
                } else {
                    // Create new marker
                    const marker = L.marker([lat, lng], { icon });
                    marker.bindPopup(popupContent);
                    marker.on('click', () => onDeviceClick(device));
                    marker.addTo(map);
                    markers[device.id] = marker;
                }
            });
        }

        // ... (getDeviceIcon and createDevicePopup remain unchanged, effectively omitted here as I am replacing a big block or I should be careful)
        // Wait, I can't strip getDeviceIcon and createDevicePopup if I use replace_big_chunk.
        // Actually, the previous tool call showed renderDevices starts at 768. getDeviceIcon starts at 795. 
        // I will only replace renderDevices and renderLinks separately or use MultiReplace.

        // Let's use MultiReplace for safety.


        // Get device icon based on type and status - matched with link colors
        function getDeviceIcon(device) {
            const iconMap = {
                customer: 'fa-user',
                ont: 'fa-router',
                olt: 'fa-server',
                odc: 'fa-box',
                odp: 'fa-cube',
                router: 'fa-network-wired',
                switch: 'fa-sitemap',
                access_point: 'fa-wifi'
            };

            // Enhanced Color Map to match Link Styles
            const typeColorMap = {
                olt: '#8B5CF6',      // Purple
                odc: '#F59E0B',      // Orange
                odp: '#3B82F6',      // Blue
                customer: device.status === 'online' ? '#10B981' : '#EF4444' // Green/Red
            };

            const statusColorMap = {
                online: '#10b981',
                offline: '#ef4444',
                warning: '#f59e0b',
                unknown: '#9ca3af'
            };

            const iconClass = iconMap[device.device_type] || 'fa-circle';
            // Prefer type color for main infra, status color for others
            const color = typeColorMap[device.device_type] || statusColorMap[device.status] || '#9ca3af';

            return L.divIcon({
                html: `
                    <div style="
                        background: ${color};
                        width: 38px;
                        height: 38px;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-size: 16px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                        border: 3px solid white;
                        transition: all 0.3s ease;
                        ${device.status === 'online' ? 'animation: pulse 2s ease-in-out infinite;' : ''}
                    ">
                        <i class="fas ${iconClass}"></i>
                    </div>
                `,
                className: 'custom-marker',
                iconSize: [38, 38],
                iconAnchor: [19, 19]
            });
        }

        // Create device popup content
        function createDevicePopup(device) {
            const statusClass = `status-${device.status}`;
            let metadata = device.metadata || {};
            // Parse metadata if user-provided as string
            if (typeof metadata === 'string') {
                try {
                    metadata = JSON.parse(metadata);
                } catch (e) {
                    console.error('Error parsing metadata', e);
                    metadata = {};
                }
            }

            let content = `
                <div class="device-popup">
                    <h4>${device.name}</h4>
                    <div class="device-popup-info">
                        <div class="device-popup-row">
                            <span class="device-popup-label">Type:</span>
                            <span class="device-popup-value">${device.device_type.toUpperCase()}</span>
                        </div>
                        <div class="device-popup-row">
                            <span class="device-popup-label">Status:</span>
                            <span class="status-badge ${statusClass}">${device.status}</span>
                        </div>
            `;

            // Signal Info (Redaman)
            if (metadata.signal) {
                const sig = metadata.signal;
                if (sig.rxPower) {
                    let rxColor = '#1e293b'; // default
                    // Parse Rx Power logic for coloring (e.g. < -27 bad)
                    const rxVal = parseFloat(sig.rxPower);
                    if (!isNaN(rxVal)) {
                        if (rxVal < -27) rxColor = '#ef4444'; // Red (Bad)
                        else if (rxVal < -24) rxColor = '#f59e0b'; // Warning
                        else rxColor = '#10b981'; // Good
                    }

                    content += `
                        <div class="device-popup-row">
                            <span class="device-popup-label">Rx Power:</span>
                            <span class="device-popup-value" style="color: ${rxColor}; font-weight: bold;">${sig.rxPower}</span>
                        </div>
                    `;
                }
                if (sig.txPower) {
                    content += `
                        <div class="device-popup-row">
                            <span class="device-popup-label">Tx Power:</span>
                            <span class="device-popup-value">${sig.txPower}</span>
                        </div>
                    `;
                }
                if (sig.temperature) {
                    content += `
                        <div class="device-popup-row">
                            <span class="device-popup-label">Temp:</span>
                            <span class="device-popup-value">${sig.temperature}</span>
                        </div>
                    `;
                }
            }

            // Calculate Distance to ODP (if customer)
            if (device.device_type === 'customer' || device.device_type === 'ont') {
                // Cari link ke ODP
                const deviceId = device.id;
                const link = currentLinks.find(l => (l.source_device_id === deviceId && deviceMap[l.target_device_id]?.device_type === 'odp') ||
                    (l.target_device_id === deviceId && deviceMap[l.source_device_id]?.device_type === 'odp'));

                if (link) {
                    const otherId = link.source_device_id === deviceId ? link.target_device_id : link.source_device_id;
                    const odpDevice = deviceMap[otherId];

                    if (odpDevice) {
                        const lat1 = parseFloat(device.latitude);
                        const lng1 = parseFloat(device.longitude);
                        const lat2 = parseFloat(odpDevice.latitude);
                        const lng2 = parseFloat(odpDevice.longitude);

                        if (!isNaN(lat1) && !isNaN(lng1) && !isNaN(lat2) && !isNaN(lng2)) {
                            const dist = map.distance([lat1, lng1], [lat2, lng2]); // in meters
                            const distText = dist > 1000 ? (dist / 1000).toFixed(2) + ' km' : Math.round(dist) + ' m';

                            content += `
                                <div class="device-popup-row">
                                    <span class="device-popup-label">ODP Source:</span>
                                    <span class="device-popup-value">${odpDevice.name}</span>
                                </div>
                                <div class="device-popup-row">
                                    <span class="device-popup-label">Jarak ke ODP:</span>
                                    <span class="device-popup-value" style="color: #3b82f6;">${distText}</span>
                                </div>
                            `;
                        }
                    }
                }
            }


            if (device.ip_address || (metadata.ip_address)) {
                content += `
                    <div class="device-popup-row">
                        <span class="device-popup-label">IP:</span>
                        <span class="device-popup-value">${device.ip_address || metadata.ip_address}</span>
                    </div>
                `;
            }

            if (device.latency_ms) {
                content += `
                    <div class="device-popup-row">
                        <span class="device-popup-label">Latency:</span>
                        <span class="device-popup-value">${device.latency_ms.toFixed(1)} ms</span>
                    </div>
                `;
            }

            if (device.packet_loss_percent) {
                content += `
                    <div class="device-popup-row">
                        <span class="device-popup-label">Packet Loss:</span>
                        <span class="device-popup-value">${device.packet_loss_percent.toFixed(1)}%</span>
                    </div>
                `;
            }

            if (device.last_seen) {
                const lastSeen = new Date(device.last_seen);
                content += `
                    <div class="device-popup-row">
                        <span class="device-popup-label">Last Seen:</span>
                        <span class="device-popup-value">${formatDateTime(lastSeen)}</span>
                    </div>
                `;
            }

            content += `
                    </div>
                </div>
            `;

            return content;
        }

        // Render network links using Leaflet Polylines
        function renderLinks(linkData) {
            const currentLinkIds = new Set();

            linkData.forEach(link => {
                const sourceDevice = deviceMap[link.source_device_id];
                const targetDevice = deviceMap[link.target_device_id];

                if (!sourceDevice || !targetDevice) return;

                const sLat = parseFloat(sourceDevice.latitude);
                const sLng = parseFloat(sourceDevice.longitude);
                const tLat = parseFloat(targetDevice.latitude);
                const tLng = parseFloat(targetDevice.longitude);

                if (isNaN(sLat) || isNaN(sLng) || isNaN(tLat) || isNaN(tLng)) return;

                // Only show links if both devices are matching active filters
                if (!activeFilters[sourceDevice.device_type] || !activeFilters[targetDevice.device_type]) return;

                const linkId = `link-${link.source_device_id}-${link.target_device_id}`;
                currentLinkIds.add(linkId);

                const sourceLatLng = [sLat, sLng];
                const targetLatLng = [tLat, tLng];

                // Determine Link Style
                let linkClass = 'network-link';
                const sType = sourceDevice.device_type;
                const tType = targetDevice.device_type;

                // Check types (bidirectional check)
                const isOltOdc = (sType === 'olt' && tType === 'odc') || (sType === 'odc' && tType === 'olt');
                const isOdcOdp = (sType === 'odc' && tType === 'odp') || (sType === 'odp' && tType === 'odc');
                const isOdpCustomer = (sType === 'odp' && tType === 'customer') || (sType === 'customer' && tType === 'odp');

                // Determine visuals
                let showDistance = false;
                let color = '#10b981'; // Default green

                if (isOltOdc) {
                    linkClass += ' link-olt-odc';
                    color = '#8B5CF6';
                    showDistance = true;
                } else if (isOdcOdp) {
                    linkClass += ' link-odc-odp';
                    color = '#3B82F6';
                    showDistance = true;
                } else if (isOdpCustomer) {
                    const customer = sType === 'customer' ? sourceDevice : targetDevice;
                    if (customer.status === 'online') {
                        linkClass += ' link-customer-online';
                        color = '#10B981';
                    } else {
                        linkClass += ' link-customer-offline';
                        color = '#EF4444';
                    }
                } else {
                    linkClass += ` link-${link.status}`;
                    color = link.status === 'up' ? '#10b981' : '#ef4444';
                }

                // Create or Update Polyline
                if (linksMap[linkId]) {
                    const poly = linksMap[linkId].polyline;
                    const oldLatLngs = poly.getLatLngs();
                    // Update connection if moved
                    if (oldLatLngs[0].lat !== sLat || oldLatLngs[0].lng !== sLng ||
                        oldLatLngs[1].lat !== tLat || oldLatLngs[1].lng !== tLng) {
                        poly.setLatLngs([sourceLatLng, targetLatLng]);
                    }
                    // Update class and color if status changed
                    if (poly.options.className !== linkClass) {
                        poly.setStyle({ className: linkClass, color: color });
                    }
                } else {
                    const polyline = L.polyline([sourceLatLng, targetLatLng], {
                        className: linkClass,
                        color: color,
                        weight: 3,
                        opacity: 0.8,
                        smoothFactor: 1
                    }).addTo(linkLayers);
                    linksMap[linkId] = { polyline };
                }

                // Add Distance Label (re-render for simplicity or if moved)
                if (showDistance) {
                    const midLat = (sourceLatLng[0] + targetLatLng[0]) / 2;
                    const midLng = (sourceLatLng[1] + targetLatLng[1]) / 2;
                    const distance = map.distance(L.latLng(sourceLatLng), L.latLng(targetLatLng));
                    const distanceText = distance > 1000 ?
                        (distance / 1000).toFixed(2) + ' km' :
                        Math.round(distance) + ' m';

                    const labelIcon = L.divIcon({
                        className: 'link-distance-wrapper',
                        html: `
                            <div class="link-distance-bg" style="
                                background: rgba(0, 0, 0, 0.7);
                                color: white;
                                padding: 2px 6px;
                                border-radius: 4px;
                                font-size: 10px;
                                font-weight: bold;
                                white-space: nowrap;
                                border: 1px solid rgba(255,255,255,0.2);
                            ">
                                ${distanceText}
                            </div>
                        `,
                        iconSize: [0, 0],
                        iconAnchor: [20, 10]
                    });

                    // We just replace the marker for simplicity as they are small
                    if (linksMap[linkId].label) linksMap[linkId].label.remove();
                    linksMap[linkId].label = L.marker([midLat, midLng], { icon: labelIcon, interactive: false }).addTo(linkLayers);
                }
            });

            // Cleanup removed links
            Object.keys(linksMap).forEach(id => {
                if (!currentLinkIds.has(id)) {
                    linksMap[id].polyline.remove();
                    if (linksMap[id].label) linksMap[id].label.remove();
                    delete linksMap[id];
                }
            });
        }


        // Update statistics
        function updateStats(stats) {
            document.getElementById('statOnline').textContent = stats.online_devices || 0;
            document.getElementById('statOffline').textContent = stats.offline_devices || 0;
            document.getElementById('statWarning').textContent = stats.warning_devices || 0;
            document.getElementById('statTotal').textContent = stats.total_devices || 0;
        }

        // Device click handler - calculate walking distance
        function onDeviceClick(device) {
            if (selectedDevice && selectedDevice.id !== device.id) {
                // Calculate walking distance between two devices
                calculateWalkingDistance(selectedDevice, device);
                selectedDevice = null;
            } else {
                selectedDevice = device;
            }
        }

        // Calculate walking distance using Leaflet Routing Machine
        function calculateWalkingDistance(device1, device2) {
            // Remove previous route
            if (routingControl) {
                map.removeControl(routingControl);
            }

            routingControl = L.Routing.control({
                waypoints: [
                    L.latLng(parseFloat(device1.latitude), parseFloat(device1.longitude)),
                    L.latLng(parseFloat(device2.latitude), parseFloat(device2.longitude))
                ],
                router: L.Routing.osrmv1({
                    serviceUrl: 'https://router.project-osrm.org/route/v1',
                    profile: 'foot' // Walking mode
                }),
                show: false,
                addWaypoints: false,
                routeWhileDragging: false,
                fitSelectedRoutes: true,
                showAlternatives: false
            }).addTo(map);

            routingControl.on('routesfound', function (e) {
                const routes = e.routes;
                const summary = routes[0].summary;

                const distanceKm = (summary.totalDistance / 1000).toFixed(2);
                const timeMin = Math.round(summary.totalTime / 60);

                // Update UI Panel
                document.getElementById('routeDistance').textContent = `${distanceKm} km`;
                document.getElementById('routeTime').textContent = `${timeMin} min`;
                document.getElementById('routeFrom').textContent = device1.name;
                document.getElementById('routeTo').textContent = device2.name;
                document.getElementById('routeInfoPanel').style.display = 'block';
            });
        }

        // Close route info panel
        function closeRouteInfo() {
            document.getElementById('routeInfoPanel').style.display = 'none';
            if (routingControl) {
                map.removeControl(routingControl);
                routingControl = null;
            }
        }

        // Toggle control panel
        function toggleControlPanel() {
            const panel = document.getElementById('controlPanel');
            const icon = document.getElementById('toggleIcon');

            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                icon.className = 'fas fa-times';
            } else {
                panel.classList.add('collapsed');
                icon.className = 'fas fa-bars';
            }
        }

        // Refresh data
        async function refreshData() {
            await loadNetworkData();
        }

        // Sync all devices
        async function syncAll() {
            const loadingDiv = document.getElementById('loadingOverlay');
            loadingDiv.style.display = 'flex';
            loadingDiv.innerHTML = `
                <div class="loading-spinner"></div>
                <div class="loading-text">Syncing devices...</div>
            `;

            try {
                // Sync GenieACS
                await fetch('/monitoring/api/sync/genieacs', { method: 'POST' });

                // Sync customers
                await fetch('/monitoring/api/sync/customers', { method: 'POST' });

                // Sync FTTH
                await fetch('/monitoring/api/sync/ftth', { method: 'POST' });

                // Auto-create links
                await fetch('/monitoring/api/sync/links', { method: 'POST' });

                // Reload data
                await loadNetworkData();
            } catch (error) {
                console.error('Error syncing:', error);
                alert('Error syncing devices');
            }
        }

        // Toggle filter
        function toggleFilter(type) {
            const checkbox = document.getElementById(`filter-${type}`);
            checkbox.checked = !checkbox.checked;
            activeFilters[type] = checkbox.checked;
            refreshData();
        }

        // Format date time
        function formatDateTime(date) {
            const now = new Date();
            const diff = now - date;
            const seconds = Math.floor(diff / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days}d ago`;
            if (hours > 0) return `${hours}h ago`;
            if (minutes > 0) return `${minutes}m ago`;
            return `${seconds}s ago`;
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initMap);
    </script>
</body>

</html>